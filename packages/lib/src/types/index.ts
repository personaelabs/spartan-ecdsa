import { PublicInput } from "@src/helpers/publicInputs";

// The same structure as MerkleProof in @zk-kit/incremental-merkle-tree.
// Not directly using MerkleProof defined in @zk-kit/incremental-merkle-tree so
// library users can choose whatever merkle tree management method they want.
export interface MerkleProof {
    root: bigint;
    siblings: [bigint][];
    pathIndices: number[];
}
export interface EffECDSAPubInput {
    Tx: bigint;
    Ty: bigint;
    Ux: bigint;
    Uy: bigint;
}

export interface NIZK {
    proof: Uint8Array;
    publicInput: PublicInput;
}

export interface ProverConfig {
    witnessGenWasm: string;
    circuit: string;
    enableProfiler?: boolean;
    useRemoteCircuit?: boolean;
}

export interface ProveArgs {
    sig: string;
    msgHash: Buffer,
    merkleProof: MerkleProof;
}

export interface VerifyArgs {
    proof: Uint8Array,
    publicInputSer: Uint8Array
}

export interface VerifyConfig {
    circuit: string; // Path to circuit file compiled by Nova-Scotia
    enableProfiler?: boolean;
    useRemoteCircuit?: boolean;
}

export interface IProver {
    circuit: string; // Path to circuit file compiled by Nova-Scotia
    witnessGenWasm: string; // Path to witness generator wasm file generated by Circom

    prove({ sig, msgHash, merkleProof }: ProveArgs): Promise<NIZK>;
}

export interface IVerifier {
    circuit: string; // Path to circuit file compiled by Nova-Scotia

    verify({ proof, publicInputSer }: VerifyArgs): Promise<boolean>;
}
